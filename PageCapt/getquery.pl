#!/usr/bin/perl

=head1 NAME

getquery.pl - a CGI program in the ScavCode PageCaptain app

=head1 DESCRIPTION

This CGI program provides the primary list querying functionality of the 
PageCaptain suite.  The F<search.html> page allows the user to directly
submit arguments to B<getquery.pl>; it is also used to provide navigation
links in the tables generated by B<User.pl> and B<getquery.pl>, and in
F<admin_edit.html> and F<update.html>.

When executed, this program outputs to the client a template page, in 
which some tags have been interpolated.  In particular, the C<QUERY> tag
is replaced with a table listing the items that matched the provided
query parameters.  The exact contents of this table depend upon the type
of query requested.

This program loads F<tables.pl>.

This program uses C<CGI> and C<Pg>.

=cut

use CGI qw/:standard/;
use Pg;

$debug = 0;

do 'tables.pl';

my $magic_tag = "<QUERY>";
$source = param('source'); if ( $source !~ /html$/ ) { die "You fool!"; }

=head2 CGI Parameters

=over 4 

=item I<source>

Required parameter, the filename of the template .html file to interpolate
and display.

=item I<type>

Pseudo-required parameter (null SQL will result from a null value -- this
is an error, but has the sensible effect of producing no rows of output).
The type of query to run.  At the moment we recognize C<keyword> (search
the description, scoring, and notes fields for a keyword), C<catsort>
(return items in a category), and C<index> (return the item with given
number).

=item I<sort>

Shouldn't be required, but bad SQL will result from a null value of this
parameter.  Specify the field used to sort the returned items.  Technically
any column in the database is allowed, but only C<points> and C<index> make
sense.  C<index> is always the fallback ordering key.

=item I<key>

Required parameter when I<type> = C<keyword>.  The value of this parameter
will be tested against the description, scoring, and notes fields using the
C<~*> SQL operator.  This is a case-insensitive string search.

=item I<cat>

Required parameter when I<type> = C<catsort>.  This parameter must be set
to the name of a category from F<tables.pl>, or to C<all>.  It is converted
to a number using the C<$category> hash and and compared to the type field.

=item I<index>

Required parameter when I<type> = C<index>.  This parameter's value is
compared literally to the index field, which will likely backfire if this
value is not numeric, and will not return results unless it is an integer. 1 

=back

=head2 Interpolated Tags

=over 4

=item C<E<lt>QUERYE<gt>>

Replaced by an HTML table containing the data returned by the executed query,
specifically the output of C<gentable()>.

=item C<E<lt>IDXE<gt>>

Replaced by the value of the I<index> parameter.

=item C<E<lt>IDX_NEXTE<gt>>

Replaced by the value of the I<index> parameter plus 1.  Assumes a numeric 
value of I<index>.

=item C<E<lt>IDX_PREVE<gt>>

Replaced by the value of the I<index> parameter minus 1.  Also assumes that
I<index> is numeric.

=back

=cut

open SOURCE, $source;

print header;

while (<SOURCE>)
  { if ( /$magic_tag/ ) { gentable() } else 
      { if ( /<IDX>/ ) { $idx = param('index'); s/<IDX>/$idx/; print $_; } 
	elsif ( /<IDX_NEXT>/ ) { $idx = param('index')+1; s/<IDX_NEXT>/$idx/; 
			      print $_; } 
	elsif ( /<IDX_PREV>/ ) { $idx = param('index')-1; s/<IDX_PREV>/$idx/; 
			      print $_; } 
	else {print $_; } } }

=head1 IMPLEMENTATION

=head2 Main Body

Open the template file.

Output the HTTP headers.

Loop over the template line-by-line.  Replace tags (searched for verbatim)
as described under L<"Interpolated Tags">.

=head2 C<gentable()>

=over 4

=item Synopsis

Return a string encoding an HTML table representing the data returned by
the query for this request.

=item Arguments

None.

=back

=cut

sub gentable
  { 
    my $query = parse_query();

=pod

Save the result of C<parse_query()>.

Check for a cookie called C<ScavAuth> to see if we are logged in.  If so,
save the UID as I<$auth_owner>.

=cut

    $auth_owner = cookie(-name=>'ScavAuth');

=pod

Establish DB connection (using hardcoded dbname/user), run query, and
check whether an error occured.  If so, print debugging information.
Print a message introducing the table.

=cut

    my $conn = Pg::connectdb("dbname=scavlist user=dummy");
    my $result = $conn->exec($query);
    my $n = $result->ntuples;
    my $error_status = $conn->errorMessage;

    print "<P>QUERY: $query</P>" if $debug || $error_status;
    print "<P>$error_status</P>" if $error_status;

    print "<P>Your search produced $n results, shown below:</P>";

=pod

Print a color code by calling C<color_code()>.

=cut

    color_code();

=pod

Print HTML table headers in the following order:

| Index | Owner | Description | Scoring | Notes | Type | Points | 

=cut

    # <COL span="2" width="0*"><COL width="2*"><COL span="2" width="1*">
    #    <COL span="2" width="1*">
    print <<EOF;
    <Table border=1 cellpadding=3 width="100%">
    <TR>
    <TH>Index<TH>Owner<TH>Item<TH>Scoring<TH>Notes<TH>Category<TH>Points</TH>
    </TR>
EOF

=pod

Generate status and category mapping arrays by sorting the C<%status>
and C<%category> hash values by key.

=cut
    @stats = sort { $status{$a} <=> $status{$b}; } keys %status; @cats =
    sort { $category{$a} <=> $category{$b}; } keys %category;

=pod

Loop over rows of the query result to generate the table, by calling
C<gen_query_row( $result, $auth_owner )>.

=cut
    for ( 0 .. $n-1 )
      { print gen_query_row( $result, $auth_owner ); };
    
    print "</Table>\n"; 
  }

=head2 C<parse_query()>

=over 4 

=item Synopsis

Parse query arguments and return an SQL query string (requires tables.pl).

=item Arguments

None.

=back

=cut

sub parse_query {

=pod

Initialize empty SQL query string.  Record the value of the I<type> 
parameter.  Initialize I<$sorting> from the I<sort> parameter, with special
cases.

=cut

my $query;
my $type = param('type');

my $sorting = param('sort');
if ( $sorting eq "points" ) { $sorting .= " DESC"; }
if ( $sorting ne "index" ) { $sorting .= ", index"; }

=pod

Construct a query using a pseudo-case block on the recorded I<$type>.  Once
constructed, return the query text.

If I<$type> is C<keyword>, record the I<key> parameter and set the query
to C<select * from list where description ~* 'I<$key>' OR scoring ~* 
'I<$key>' OR notes ~* 'I<$key>' order by I<$sorting>>.

=cut

if ( $type eq "keyword" )
  { my $search_key = param('key');
    $query = "select * from list where ";
    $query .= "description ~* \'$search_key\' OR ";
    $query .= "scoring ~* \'$search_key\' OR ";
    $query .= "notes ~* \'$search_key\' ";
    $query .= "order by $sorting"; 
  }

=pod

If I<$type> is C<catsort>, get a category name from the I<cat> parameter.
If I<cat> is C<all>, there is no category condition; otherwise the condition
is C<where type = I<catnum>> (determined from the C<%category> hash), and
the query is C<select * from list I<$condition> order by I<$sorting>>.

=cut

if ( $type eq "catsort" )
  { my $search_cat = param('cat');
    my $cat_cond;
    
    if ( $search_cat eq "all" ) {$cat_cond = "" } else
      { $cat_cond = "where type = $category{$search_cat}"; }
    $query = "select * from list $cat_cond order by $sorting"; 
  }

=pod

If I<$type> is C<index>, retrieve the I<index> parameter and set the query
to C<select * from list where index = I<$index>>.

=cut

if ( $type eq "index" )
  { my $index = param('index');
    $query = "select * from list where index = $index"; 
  }

return $query;
}

=head2 C<color_code()>

=over 4

=item Synopsis

Print to I<STDOUT> the HTML code for a tabular color code key to the status
flags using tables.pl hashes.  Returns nothing.

=back

Print header material.  Loop over the keys of I<%status>.  Output table
cells with background color set to the corresponding color from I<%statcol>.
Print closing tags.

=cut

sub color_code {

  print "Color Code: \n";
  print "<Table border=1>";
  foreach ( keys %status )
    { $colstr = "";
      if ( $statcol{$_} ne "" ) { $colstr = " bgcolor=\"$statcol{$_}\""; }
      print "<TD$colstr>$_</TD>"; }
  print "</Table>\n<P>\n";

}

=head2 C<gen_query_row( I<$result>, I<$auth_user> )>

=over 4

=item Synopsis

Return an HTML table row for our query.  Uses tables.pl.

gen_query_row( $result, $auth_owner );

| Index | Owner | Description | Scoring | Notes | Type | Points | 

=item Arguments

I<$result> is a Pg result object as returned by C<$conn->exec($query)>.

I<$auth_user> is the UID number of the requesting user.

=back

=cut

sub gen_query_row {

  my $result = shift;
  my $auth_owner = shift;

=pod

Retrieve a row of the result table, corresponding to one item.

=cut

  ( my $r_index,
    my $r_points,
    my $r_type,
    my $r_status,
    my $r_desc,
    my $r_scoring,
    my $r_notes,
    my $r_owner ) = $result->fetchrow;

=pod

If one exists, look up the owner of this item (nick, name) in the DB
(creating a new connection).  Create a link to C<User.pl?uid=I<$uid>>
with the name as link text.

=cut

  my $owner_link;
  if ( $r_owner )
    { my $conn = Pg::connectdb("dbname=scavlist user=postgres password=timelord");
      my $query = "SELECT nick, name FROM users WHERE owner = $r_owner";
      my $result = $conn->exec($query);
      ( my $r_nick, my $r_name ) = $result->fetchrow;
      my $text = $r_nick;
      $text = $r_name if $r_name;
      $owner_link = "<A href=\"User.pl?uid=$r_owner\">$text</A>";
    }

=pod

Use tables.pl hashes to get a status color and category name.

Call choose_item_form( $auth_owner, $r_owner, $r_index ) to get a control
object.

Construct and return the HTML for a row as

    <tr bgcolor=$color>
    <td>$r_index<P>
    $form
    </td>
    <td>$owner_link</td>
    <td>$r_desc</td>
    <td>$r_scoring</td>
    <td>$r_notes</td>
    <td>$cat</td>
    <td>$r_points</td>
    </tr>

=cut

  my $color = $statcol{$stats[$r_status]};
  my $cat = $cats[$r_type];
  
  my $form = choose_item_form( $auth_owner, $r_owner, $r_index );
  my $return_string = <<EOF;

<tr bgcolor=$color>
<td>$r_index<P>
$form
</td>
<td>$owner_link</td>
<td>$r_desc</td>
<td>$r_scoring</td>
<td>$r_notes</td>
<td>$cat</td>
<td>$r_points</td>
</tr>

EOF

  return $return_string;
}

=head2 C<choose_item_form( $owner, $item_owner, $item_index )>

=over 4

=item Arguments

I<$owner> is the UID of the requesting user.

I<$item_owner> is the UID of the user who has claimed this item.

I<$item_index> is the index of the item in question.

=item Synopsis

Combine the identities of the requesting user and the owner of the item to
select the appropriate control object for this row from four possibilities.
Each control performs an index search for the item using L<getquery.pl> and
a different template bearing appropriate controls.

I<$form_admin> uses a template with administrative controls for the record.

I<$form_edit> uses a template with controls that allow the user to update
the item.

I<$form_view> uses a template which only provides the ability to add to the
comments field.

I<$form_claim> uses a template giving the user the option to claim an
unclaimed item, edit the status or category, or add a comment.

=cut

sub choose_item_form {

  my $owner = shift;
  my $item_owner = shift;
  my $item_index = shift;

  my $form_admin = <<EOF;
<form action="getquery.pl" method="get">
	<input type="hidden" name="type" value="index">
	<input type="hidden" name="source" value="admin_edit.html">
	<input type="hidden" name="index" value="$item_index">
	<input type="submit" value="Admin">
</form>
EOF

  my $form_edit = <<EOF;
<form action="getquery.pl" method="get">
	<input type="hidden" name="type" value="index">
	<input type="hidden" name="source" value="owner_edit.html">
	<input type="hidden" name="index" value="$item_index">
	<input type="submit" value="Edit">
</form>
EOF

  my $form_view = <<EOF;
<form action="getquery.pl" method="get">
	<input type="hidden" name="type" value="index">
	<input type="hidden" name="source" value="annotate.html">
	<input type="hidden" name="index" value="$item_index">
	<input type="submit" value="Note">
</form>
EOF

  my $form_claim = <<EOF;
<form action="getquery.pl" method="get">
	<input type="hidden" name="type" value="index">
	<input type="hidden" name="source" value="update.html">
	<input type="hidden" name="index" value="$item_index">
	<input type="submit" value="Ed/Claim">
</form>
EOF

=pod

The logic is as follows:

  # If we are admin, we can do cool stuff with it: $form_admin
  # If nobody owns this item, anyone can edit or claim it: $form_claim
  # If this user owns this item, they get full privileges: $form_edit
  # If someone else owns this item, they can only annotate: $form_view
  # If this user isn't logged in, they can only annotate: $form_view

=back

=cut

  my $form_choice = $form_view;
  if ( $owner )
    { $form_choice = $form_claim unless $item_owner;
      $form_choice = $form_edit if $owner == $item_owner;
      $form_choice = $form_admin if $owner == 1;
    }

  return $form_choice;
}
