#!/usr/bin/perl

=head1 NAME

AddUser.pl - a CGI program in the ScavCode PageCaptain app

=head1 DESCRIPTION

This CGI program is a single-purpose tool for creating or updating a user
record in the database.  It is called from the F<adduser.html> page, which
also serves as the output template for this script.  The usual means of
accessing this script will be via a form generated by the L<User.pl> script.

Upon execution, the F<adduser.html> file will be printed to the client, with
the C<MESSAGE> tag interpolated into an error or informational status message.

This program uses C<CGI> and C<Pg>.

=cut

use CGI qw/:standard/;
use Pg;

=head2 CGI Parameters

=over 4

=item I<nick>

Required.  The nickname of the user record; this will be used as a login ID.

=item I<name>

Required.  The full (or at least public) name of the user.

=item I<address> I<phone> I<email> I<contact>

At least one of these four parameters must be supplied.  They are free-form
contact information fields, although it is preferred that users use them as
their names suggest.

=item I<password>

Required parameter.  This password will be required to obtain a login cookie.

=item I<backup>

Required.  Must be identical to I<password>.

=item I<edit>

If the program is invoked with the intent to update an existing user record,
this parameter should be set to the UID of that record.  Otherwise it should
not be set.

=back

This program also checks for a browser cookie called I<ScavAuth> and if set
retrieves the UID under which the client is logged in.

The update will only be allowed if the client is logged in as the I<edit>
user, or if the client is logged in under UID 1 (the administrator).

=cut

my $nick = Sanitize(param('nick'));
my $name = Sanitize(param('name'));
my $address = Sanitize(param('address'));
my $phone = Sanitize(param('phone'));
my $email = Sanitize(param('email'));
my $contact = Sanitize(param('contact'));
my $password = Sanitize(param('password'));
my $backup = Sanitize(param('backup')); # Backup password, that is

my $edit_user = param('edit');
my $auth_user = cookie(-name=>'ScavAuth');
my $auth = 0;

=head1 IMPLEMENTATION

=head2 Main Body

Read in the CGI parameters; all except I<edit> and I<ScavAuth> are filtered
through C<Sanitize()>.

Check authorization.  Set the I<$auth> flag if the I<edit> user == the
I<ScavAuth> user, or if C<I<ScavAuth> == 1>.

Establish a DB connection.  Connection parameters are hardcoded here.

=cut

$auth = 1 if $edit_user && ( $edit_user == $auth_user );
if ( $auth_user == 1 ) {
  $edit_user = $auth_user;
  $auth = 1;
}

# Connect to DB
$conn = Pg::connectdb("dbname=scavlist user=postgres password=timelord");

=pod

Perform a series of validation checks:

Query the database for the value of I<nick>.  Unless I<$auth> is set, a
nonzero number of returned records causes us to abort with a "Nickname taken"
message to the ReDo subroutine.

=cut

# User name taken?
$match = $conn->exec("select owner from users where nick = \'$nick\'");
ReDo("<h2><center>Nickname taken ... please try again.</center></h2>")
  unless ( $match->ntuples == 0 ) || $auth;

=pod

Abort to ReDo with appropriate message, unless I<$password> is set, and
C<I<$password> eq I<$backup>>.

Abort C<unless I<$nick> && I<$name> && ( I<$address> || I<$phone> || I<$email>
|| I<$contact> )>.

=cut

# Does he know his password?
ReDo("<h2><center>
Your passwords don't match ... please try again.
</center></h2>")
  unless $password eq $backup;

# Does he have a password?
ReDo("<h2><center>You really need a password.</center></h2>")
  unless $password;

# A few other things we want.
ReDo("<h2><center>Please supply the required information.</center></h2>")
  unless $nick && $name && ( $address || $phone || $email || $contact );

=pod

We are good to go -- insert/edit user.  If I<$auth> is set, we generate an
C<UPDATE users ...> SQL statement, otherwise generate an C<INSERT INTO users
...>.  On C<UPDATE>, the I<edit> UID is the selection key.

=cut

my $query;
if ( $auth ) {
$query = "UPDATE users ";
$query .= "SET ";
$query .= "nick = \'$nick\', " if $nick;
$query .= "name = \'$name\', ";
$query .= "address = \'$address\', ";
$query .= "phone = \'$phone\', ";
$query .= "email = \'$email\', ";
$query .= "contact = \'$contact\', ";
$query .= "password = \'$password\' ";
$query .= "WHERE owner = $edit_user" }
else {
$query = "INSERT into users ";
$query .= "( nick, name, address, phone, email, contact, password ) ";
$query .= "VALUES ( ";
$query .= "\'$nick\', ";
$query .= "\'$name\', ";
$query .= "\'$address\', ";
$query .= "\'$phone\', ";
$query .= "\'$email\', ";
$query .= "\'$contact\', ";
$query .= "\'$password\' ";
$query .= ")"; }

=pod

Execute the SQL statement.  Unless an error message is generated, prepare a
debugging message for output.  This is a logic bug.

Retrieve the record just created/updated, by I<nick>.  If an error message
results, prepare a debugging message (which overwrites the message from the
previous operation).

=cut

$result = $conn->exec($query);
$status = $conn->errorMessage;
$message = "<h2>Something went wrong. Error message follows. Tell Michael.</h2>
<P>DID: $query</P>
<P>GOT: $status</P>"
  unless $status;

$query = "SELECT nick, name, address, phone, email, contact ";
$query .= "FROM users WHERE nick = \'$nick\'";
$result = $conn->exec($query);
$status = $conn->errorMessage;
$message = "<h2>Something went wrong. Error message follows. Tell Michael.</h2>
<P>DID: $query</P>
<P>GOT: $status</P>"
  if $status;

( $nick, $name, $address, $phone, $email, $contact ) = $result->fetchrow;

=pod

Exit by calling UserResults.  This should only occur when we have edited a
user, but the call is unconditional.  This is a bug.

If we created a user and the above bug did not exist, we would append a
confirmation message including the created record data to the existing output
message.  This is passed to ReDo to exit the program.

=cut

UserResults( $edit_user );

$message .= <<EOF;
<h3><center>
Please confirm your information is correct. If it is not, please 
contact the <A href="mailto:mbmillig\@midway.uchicago.edu">web-guru</A>
to fix whatever you screwed up. He didn\'t have time to write a way for
you to do this yourself. Oh well.
</center></h3>
<table align="center">
  <tr align="left"><td>Nickname:</td><td>$nick</td></tr>
  <tr align="left"><td>Real Name:</td><td>$name</td></tr>
  <tr align="left"><td>Address:</td><td>$address</td></tr>
  <tr align="left"><td>Phone:</td><td>$phone</td></tr>
  <tr align="left"><td>Email:</td><td>$email</td></tr>
  <tr align="left"><td>Other:</td><td>$contact</td></tr>
</table>
<h3 align="center">Only fill out the information below to create another
user. If you see the correct information above, your user <B>has been
successfully created</B>. Thank you.</h3>
EOF

ReDo($message);

=head2 C<ReDo( I<$message> )>

=over 4

=item Synopsis

Prints to the client HTTP headers and the contents of the template file,
specified in this routine as F<adduser.html>.  A message will be written in
place of the string C<E<lt>MESSAGEE<gt>> in the template.  This routine exits
the program after seeing EOF on the template.

=item Arguments

I<$message> is the string to be substituted into the template.

=back

=cut

# This is where we end up, one way or another. It doesn't return. It
# simply spits out a canned html form with the given message inserted.
sub ReDo {

  my $magic_tag = "<MESSAGE>";
  my $source = "adduser.html";
  my $message = $_[0];
  
  print header;

  open SOURCE, $source;
  
  while (<SOURCE>) {
    if ( /$magic_tag/ ) { print $message; }
    else { print $_; }
  }

  exit 0;
}

=head2 C<UserResults( I<$edit_user> )>

=over 4

=item Synopsis

This routine prints to the client an HTTP redirect that invokes the L<User.pl>
program with the I<uid> set to I<$edit_user>, and exits the program.

If we are editing the user info, we go here.

=item Arguments

I<$edit_user> is the UID of the user record to be retrieved.

=back

=cut

sub UserResults {
  my $edit_user = shift;

  my $uri = "http://neutrino.homeip.net/scav/User.pl?uid=$edit_user";
  print redirect(-uri=>$uri);
  exit 0;
}

=head2 C<Sanitize( I<$string> )>

=over 4

=item Synopsis

This should strip out leading and trailing space, and escape any single-quotes
(but not unescape them).  This prepares user-supplied data for storage into the database by ensuring that no sequence of characters can be introduced into an SQL query that would terminate the surrounding quotes and thus be potentially parsed as SQL commands.

=item Arguments

I<$string> is a string to be sanitized.

=back

=cut

sub Sanitize {

  my $string = $_[0];

  $string =~ s/^\s+//gm;
  $string =~ s/\s+$//gm;

  $string =~ s/^'/\\'/mg;
  $string =~ s/([^\\])'/$1\\'/g;

  return $string;
}
